{"version":3,"sources":["components/Point.tsx","components/Board.tsx","components/SnakeGame.tsx","App.tsx","reportWebVitals.ts","index.tsx"],"names":["Point","className","gameTrigger","boardState","x","y","isSnake","snake","snakeBegin","restOfSnake","isHead","isTail","some","el","composedClassName","targetPoint","onClick","applyAxis","index","movingInterval","FREQUENCY","initialBoardState","boardSize","started","interrupt","Board","children","useReducer","boardReducer","dispatch","width","height","newDirection","clearInterval","type","snakeHead","snakeHeadX","snakeHeadY","xDirection","yDirection","i","setInterval","reDispatchMove","snakeMove","boardCore","push","state","action","console","log","tail","newPosition","head","newSnakeHead","point","isWall","generateRandomPoint","newX","Math","floor","random","newY","SnakeGame","App","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.519a0119.chunk.js","sourcesContent":["import React from 'react';\n\nexport function Point({ className = '', gameTrigger, boardState, x, y }: any) {\n\n\tconst isTarget = () => {\n\t\tif (x === boardState.targetPoint[0] && y === boardState.targetPoint[1]) {\n\t\t\treturn 'target';\n\t\t} else {\n\t\t\treturn '';\n\t\t}\n\t}\n\n\tconst isSnake = () => {\n\t\tconst [snakeBegin, ...restOfSnake] = boardState.snake;\n\n\t\tconst isHead = x === snakeBegin[0] && y === snakeBegin[1];\n\t\tconst isTail = restOfSnake.some((el: any) => {\n\t\t\treturn x === el[0] && y === el[1];\n\t\t});\n\n\t\tif (isHead) {\n\t\t\treturn 'snake head';\n\t\t} else if (isTail) {\n\t\t\treturn 'snake tail';\n\t\t} else {\n\t\t\treturn '';\n\t\t}\n\t}\n\n\tconst composedClassName = `${isTarget()} ${isSnake()} ${className}`;\n\n\tconst onPointClickHandler = (/* e: any */) => {\n\t\treturn !isSnake() ? gameTrigger([x, y]) : null;\n\t};\n\n\treturn <div className={`point ${composedClassName}`} onClick={onPointClickHandler}>{applyAxis(x, y)}</div>\n}\n\nfunction applyAxis(x: number, y: number) {\n\tlet index: any = '';\n\n\tif (x === 0 && y === 0) {\n\t\tindex = 0;\n\t} else if (x === 0 && y > 0) {\n\t\tindex = 'y' + y;\n\t} else if (y === 0 && x > 0) {\n\t\tindex = 'x' + x;\n\t}\n\n\treturn index;\n}\n","import React, { useReducer, PropsWithChildren } from 'react';\nimport { Point } from './Point';\nimport './board.css';\n\nconst FREQUENCY = 1000;\n\n// Array for axis used in format [x y] of two positive numbers:\n// y top-to-bottom and\n// x left-to-right\nconst initialBoardState = {\n    boardSize: [8, 8],\n    targetPoint: [2, 5],\n    snake: [[4, 5]],\n    // snake: [[4, 5], [4, 6], [5, 6], [6, 6]],\n    // snake: { // alternative\n    //     head: [],\n    //     tail: []\n    // },\n    started: false,\n    interrupt: false,\n    // conflict: false, // target | itself | edge\n};\n\nlet movingInterval: any;\n\n// Approach using <div> and css-grid layout\nexport function Board({ children }: PropsWithChildren<any>) {\n    // console.log('Board re-render');\n\n    const [boardState, dispatch] = useReducer(\n        boardReducer,\n        initialBoardState\n    );\n\n    const width = boardState.boardSize[0];\n    const height = boardState.boardSize[1];\n    // const matrix = Array(width).fill(null).map(el => Array(height).fill(0));\n    // console.log(matrix);\n\n    // This must be created on demand, after click for every cell once. NOT MORE\n    const gameTrigger = (newDirection: number[/* x y */]) => {\n        if (!boardState.started) {\n            dispatch({ type: 'START' });\n        } else {\n            clearInterval(movingInterval);\n            dispatch({ type: 'INTERRUPT' });\n        }\n\n        snakeMove(boardState, newDirection, dispatch);\n    };\n\n    const boardCore = [];\n    for (let x = 0; x < width; x++) {\n        for (let y = 0; y < height; y++) {\n            // console.log('loop re-invoke');\n            // TODO improve performance\n            // Every cell on the board changed, every snake moved, this loop will be re-invoked.\n            boardCore.push(<Point gameTrigger={gameTrigger} boardState={boardState} x={x} y={y} key={`cell-x[${x}]-y[${y}]`} />);\n        }\n    }\n\n    return (\n        <>\n            <div className=\"wrapper\">\n                {boardCore}\n            </div>\n            {children}\n        </>\n    );\n}\n\nfunction boardReducer(state: any, action: any) {\n    // console.log('boardReducer'); // TODO\n    // Due to using <React.StrictMode> useReducer() -> reducer() function is double-invoking !!!\n    // https://reactjs.org/docs/strict-mode.html#detecting-unexpected-side-effects\n    // console.log() inside of switch case is once, but random array is regenerated twice\n    // SOLUTION: move ANY logic BEFORE dispatch() and pass any new changed data via dispatch() func.\n    // https://github.com/facebook/react/issues/16295\n    // https://stackoverflow.com/questions/54892403/usereducer-action-dispatched-twice\n\n    switch (action.type) {\n        case 'START':\n            console.log('Game STARTED');\n            return {\n                ...state,\n                started: true // and start while(1) loop OR setInterval()\n            }\n\n        case 'FINISH':\n            console.log('Game Over!');\n\n            return {\n                ...state,\n                started: false, // and stop while(1) loop OR setInterval()\n                // targetPoint: generateRandomPoint('target'), // BAD\n                // snake: [generateRandomPoint('snakeHead')] // BAD\n            }\n\n        case 'SNAKE_MOVE': {\n            console.log('Snake is MOVING');\n\n            const [, ...tail] = state.snake;\n\n            return {\n                ...state,\n                snake: [action.newPosition, ...tail],\n                interrupt: false\n            }\n        }\n\n        case 'GROW_SNAKE': {\n            console.log('Snake is GROWING');\n\n            // state.snake.unshift(action.newDirection);\n            // state.snake.pop(); // add a keyframe animation for slow fade out of last point on tail\n\n            // state.snake[0] = action.newPosition; // MUTABLE !!!!\n\n            // TODO\n            // const [snakeHead, ...snakeTail] = state.snake; // snakeTail can be undefined or many arrays [].length == 2\n            // TODO\n\n            const [head, ...tail] = state.snake;\n            console.log(tail);\n            tail.push(action.newPosition);\n            console.log(tail);\n\n            return {\n                ...state,\n                snake: [head, ...tail],\n                interrupt: false\n            }\n        }\n\n        case 'CONFLICT_WITH_TARGET':\n            console.log('Target point reached. Generating new one.');\n            // when snake eats target [xT, yT], size should be increased - new sub-array will be pushed to boardState.snake\n\n            // action.newPosition;\n\n            return {\n                ...state,\n                // targetPoint: generateRandomPoint('target'), // BAD\n                // snake: [generateRandomPoint('snakeHead')] // BAD\n            }\n\n        case 'CONFLICT_WITH_ITSELF':\n            console.log('Don\\'t eat yourself');\n\n            return {\n                ...state,\n                // targetPoint: generateRandomPoint('target'), // BAD\n                // snake: [generateRandomPoint('snakeHead')] // BAD\n            }\n\n        case 'CONFLICT_WITH_EDGES':\n            console.log('Bang...');\n\n            return {\n                ...state,\n                started: false,\n                targetPoint: action.newPosition, // SHOULD BE OK\n                snake: [action.newSnakeHead] // SHOULD BE OK\n            }\n\n        case 'REGENERATE_TARGET':\n            console.log('Target point regeneration.');\n\n            return {\n                ...state,\n                targetPoint: action.newPosition, // IS OK\n            }\n\n        case 'REGENERATE_SNAKE':\n            console.log('Snake head point regeneration.');\n\n            return {\n                ...state,\n                snake: [action.newPosition], // IS OK. Will cause disappearing snake's tail, and head will be new point.\n            }\n        case 'INTERRUPT':\n            console.log('INTERRUPT');\n\n            return {\n                ...state,\n                interrupt: true\n            }\n\n        default:\n            return state;\n    }\n}\n\n/**\n * top: x = const, y--\n * bottom: x = const, y++\n * left: x--, y = const\n * right: x++, y = const\n *\n * @param boardState\n * @param newDirection\n * @param dispatch\n */\nfunction snakeMove(boardState: any, newDirection: any, dispatch: any) {\n    const snakeHead = boardState.snake[0];\n    const [snakeHeadX, snakeHeadY] = snakeHead;\n    const [xDirection, yDirection] = newDirection;\n\n    if (yDirection === snakeHeadY) {\n        // it is LEFT or RIGHT move of snake head\n\n        if (xDirection < snakeHeadX) { // -- loop = LEFT MOVE\n\n            let i = snakeHeadX - 1; // next left point\n\n            const callback = () => {\n                reDispatchMove(dispatch, boardState, [i, yDirection]);\n                --i; // maybe i--\n            };\n\n            movingInterval = setInterval(callback, FREQUENCY);\n        } else { // ++ loop = RIGHT MOVE\n\n            if (movingInterval) {\n                clearInterval(movingInterval);\n            }\n\n            // let interval2: any;\n            let i = snakeHeadX + 1; // next right point\n\n            const callback = () => {\n                reDispatchMove(dispatch, boardState, [i, yDirection]);\n                ++i; // maybe i++\n            };\n\n            movingInterval = setInterval(callback, FREQUENCY);\n        }\n    } else {\n        // use case when clicked point NOT on the same Y axis\n    }\n\n    if (xDirection === snakeHeadX) {\n        // it is TOP or BOTTOM move\n        if (yDirection < snakeHeadY) {\n            // -- for loop = TOP MOVE\n        } else {\n            // ++ for loop = BOTTOM MOVE\n        }\n    } else {\n        // use case when clicked point NOT on the same X axis\n    }\n}\n\nfunction reDispatchMove(dispatch: any, boardState: any, newPosition: number[]) {\n    if (isWall(newPosition)) {\n        clearInterval(movingInterval);\n        dispatch({ type: 'FINISH' });\n        dispatch({ type: 'REGENERATE_TARGET', newPosition: generateRandomPoint('target') });\n        dispatch({ type: 'REGENERATE_SNAKE', newPosition: generateRandomPoint('snakeHead') });\n        return;\n    }\n\n    dispatch({ type: 'SNAKE_MOVE', newPosition });\n\n    const isTargetEaten = newPosition[0] === boardState.targetPoint[0] && newPosition[1] === boardState.targetPoint[1];\n    if (isTargetEaten) {\n        // boardState.snake.push(newPosition);\n        dispatch({ type: 'GROW_SNAKE', newPosition });\n        dispatch({ type: 'REGENERATE_TARGET', newPosition: generateRandomPoint('target') });\n    }\n}\n\nfunction generateRandomPoint(type: string) {\n    const newX = Math.floor(Math.random() * initialBoardState.boardSize[0]);\n    const newY = Math.floor(Math.random() * initialBoardState.boardSize[1]);\n\n    // Extend logic to avoid:\n    // same point as target, which was before\n    // same point of snake head or tail\n    // etc.\n    console.log(type + ' new random point', [newX, newY]);\n\n    return [newX, newY];\n}\n\nfunction isWall(point: number[]) {\n    const [x, y] = point;\n\n    if (x < 0) {\n        return true; // left edge, x has been decreasing towards 0\n    }\n    if (x > initialBoardState.boardSize[0] - 1) {\n        return true; // right edge, x has been increasing from positive number towards board width edge\n    }\n    if (y < 0) {\n        return true; // top edge, y has been decreasing towards 0\n    }\n    if (y > initialBoardState.boardSize[1] - 1) {\n        return true; // right edge, x has been increasing from positive number towards board height edge\n    }\n\n    return false;\n}\n\n","import React from 'react';\nimport { Board } from './Board';\n// import { Point } from './Point';\n// import { Snake } from './Snake';\n\n// import './snake-game.css';\n\n// OR random   Math.random(10, 0);\nexport function SnakeGame() {\n  // dynamics, re-renders, etc\n\n  return (\n    <Board>\n    </Board>\n  );\n}\n","import React from 'react';\nimport { SnakeGame } from './components/SnakeGame';\nimport './App.css';\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <header className=\"\">\n      </header>\n      <main>\n        <SnakeGame />\n      </main>\n    </div>\n  );\n}\n\nexport default App;\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  // https://stackoverflow.com/questions/54892403/usereducer-action-dispatched-twice\n  // in strict mode, dispatch() from useReducer() was/is executed twice\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}