{"version":3,"sources":["components/Point.tsx","components/Board.tsx","components/SnakeGame.tsx","App.tsx","reportWebVitals.ts","index.tsx"],"names":["Point","className","gameTrigger","boardState","x","y","isSnake","snake","snakeBegin","restOfSnake","isHead","isTail","some","el","composedClassName","targetPoint","onClick","applyAxis","index","movingInterval","FREQUENCY","initialBoardState","boardSize","started","interrupt","conflict","Board","children","useReducer","boardReducer","dispatch","width","height","newDirection","clearInterval","type","snakeHead","snakeHeadX","snakeHeadY","xDirection","yDirection","i","setInterval","reDispatchMove","snakeMove","boardCore","push","state","action","console","log","previousHead","tail","length","pop","unshift","newPosition","head","newSnakeHead","point","isWall","regeneratePoints","isTargetEaten","generateRandomPoint","isItselfEaten","setTimeout","newX","Math","floor","random","newY","SnakeGame","App","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"uTAGO,SAASA,EAAT,GAAwE,IAAD,IAAtDC,iBAAsD,MAA1C,GAA0C,EAAtCC,EAAsC,EAAtCA,YAAaC,EAAyB,EAAzBA,WAAYC,EAAa,EAAbA,EAAGC,EAAU,EAAVA,EAU7DC,EAAU,WAAO,IAAD,cACgBH,EAAWI,OAAzCC,EADc,KACCC,EADD,WAGfC,EAASN,IAAMI,EAAW,IAAMH,IAAMG,EAAW,GACjDG,EAASF,EAAYG,MAAK,SAACC,GAChC,OAAOT,IAAMS,EAAG,IAAMR,IAAMQ,EAAG,MAGhC,OAAIH,EACI,aACGC,EACH,aAEA,IAIHG,EAAiB,UAxBlBV,IAAMD,EAAWY,YAAY,IAAMV,IAAMF,EAAWY,YAAY,GAC5D,SAEA,GAqBc,YAAoBT,IAApB,YAAiCL,GAMxD,OAAO,qBAAKA,UAAS,gBAAWa,GAAqBE,QAJzB,WAC3B,OAAQV,IAAkC,KAAtBJ,EAAY,CAACE,EAAGC,KAG9B,SAA6EY,EAAUb,EAAGC,KAGlG,SAASY,EAAUb,EAAWC,GAC7B,IAAIa,EAAa,GAUjB,OARU,IAANd,GAAiB,IAANC,EACda,EAAQ,EACQ,IAANd,GAAWC,EAAI,EACzBa,EAAQ,IAAMb,EACE,IAANA,GAAWD,EAAI,IACzBc,EAAQ,IAAMd,GAGRc,E,UC3BJC,EAnBEC,EAAY,IAKZC,EAAoB,CACtBC,UAAW,CAAC,EAAG,GACfP,YAAa,CAAC,EAAG,GACjBR,MAAO,CAAC,CAAC,EAAG,IAMZgB,SAAS,EACTC,WAAW,EACXC,UAAU,GAMP,SAASC,EAAT,GA0BH,IA1ByD,IAArCC,EAAoC,EAApCA,SAAoC,EAGzBC,qBAC3BC,EACAR,GALoD,mBAGjDlB,EAHiD,KAGrC2B,EAHqC,KAQlDC,EAAQ5B,EAAWmB,UAAU,GAC7BU,EAAS7B,EAAWmB,UAAU,GAK9BpB,EAAc,SAAC+B,GACZ9B,EAAWoB,SAGZW,cAAcf,GACdW,EAAS,CAAEK,KAAM,eAHjBL,EAAS,CAAEK,KAAM,UAkK7B,SAAmBhC,EAAiB8B,EAAmBH,GACnD,IAAMM,EAAYjC,EAAWI,MAAM,GAD+B,cAEjC6B,EAFiC,GAE3DC,EAF2D,KAE/CC,EAF+C,mBAGjCL,EAHiC,GAG3DM,EAH2D,KAG/CC,EAH+C,KAMlE,GAAIA,IAAeF,EAEf,GAAIC,EAAaF,EAAY,CACzB,IAAII,EAAIJ,EAAa,EAKrBlB,EAAiBuB,aAJA,WACbC,EAAeb,EAAU3B,EAAY,CAACsC,EAAGD,MACvCC,IAEiCrB,OACpC,CAECD,GACAe,cAAcf,GAGlB,IAAIsB,EAAIJ,EAAa,EAKrBlB,EAAiBuB,aAJA,WACbC,EAAeb,EAAU3B,EAAY,CAACsC,EAAGD,MACvCC,IAEiCrB,GAO/C,GAAImB,IAAeF,EACf,GAAIG,EAAaF,EAAY,CAEzB,IAAIG,EAAIH,EAAa,EAKrBnB,EAAiBuB,aAJA,WACbC,EAAeb,EAAU3B,EAAY,CAACoC,EAAYE,MAChDA,IAEiCrB,OAEpC,CAECD,GACAe,cAAcf,GAGlB,IAAIsB,EAAIH,EAAa,EAKrBnB,EAAiBuB,aAJA,WACbC,EAAeb,EAAU3B,EAAY,CAACoC,EAAYE,MAChDA,IAEiCrB,IAlN3CwB,CAAUzC,EAAY8B,EAAcH,IAGlCe,EAAY,GACTzC,EAAI,EAAGA,EAAI2B,EAAO3B,IACvB,IAAK,IAAIC,EAAI,EAAGA,EAAI2B,EAAQ3B,IAIxBwC,EAAUC,KAAK,cAAC9C,EAAD,CAAOE,YAAaA,EAAaC,WAAYA,EAAYC,EAAGA,EAAGC,EAAGA,GAAlE,iBAAoFD,EAApF,eAA4FC,EAA5F,OAIvB,OACI,qCACI,qBAAKJ,UAAU,UAAf,SACK4C,IAEJlB,KAKb,SAASE,EAAakB,EAAYC,GAS9B,OAAQA,EAAOb,MACX,IAAK,QAED,OADAc,QAAQC,IAAI,gBACL,2BACAH,GADP,IAEIxB,SAAS,IAGjB,IAAK,SAGD,OAFA0B,QAAQC,IAAI,cAEL,2BACAH,GADP,IAEIxB,SAAS,IAKjB,IAAK,aACD0B,QAAQC,IAAI,mBADG,kBAGiBH,EAAMxC,OAA/B4C,EAHQ,KAGSC,EAHT,WASf,OALIA,EAAKC,OAAS,IACdD,EAAKE,MACLF,EAAKG,QAAQJ,IAGV,2BACAJ,GADP,IAEIxC,MAAM,CAAEyC,EAAOQ,aAAV,mBAA0BJ,IAC/B5B,WAAW,IAInB,IAAK,aACDyB,QAAQC,IAAI,oBADG,kBAYSH,EAAMxC,OAAvBkD,EAZQ,KAYCL,EAZD,WAef,OAFAA,EAAKG,QAAQP,EAAOQ,aAEb,2BACAT,GADP,IAEIxC,MAAM,CAAEkD,GAAH,mBAAYL,IACjB5B,WAAW,IAInB,IAAK,uBAID,OAHAyB,QAAQC,IAAI,6CAGL,eACAH,GAKX,IAAK,uBAGD,OAFAE,QAAQC,IAAI,sBAEL,2BACAH,GADP,IAEItB,SAAU,WAKlB,IAAK,sBAGD,OAFAwB,QAAQC,IAAI,WAEL,2BACAH,GADP,IAEIxB,SAAS,EACTR,YAAaiC,EAAOQ,YACpBjD,MAAO,CAACyC,EAAOU,gBAGvB,IAAK,oBAGD,OAFAT,QAAQC,IAAI,8BAEL,2BACAH,GADP,IAEIhC,YAAaiC,EAAOQ,cAG5B,IAAK,mBAGD,OAFAP,QAAQC,IAAI,kCAEL,2BACAH,GADP,IAEIxC,MAAO,CAACyC,EAAOQ,eAEvB,IAAK,YAGD,OAFAP,QAAQC,IAAI,aAEL,2BACAH,GADP,IAEIvB,WAAW,IAGnB,QACI,OAAOuB,GA4EnB,SAASJ,EAAeb,EAAe3B,EAAiBqD,IA4CxD,SAAgBG,GAAkB,IAAD,cACdA,EADc,GACtBvD,EADsB,KACnBC,EADmB,KAG7B,GAAID,EAAI,EACJ,OAAO,EAEX,GAAIA,EAAIiB,EAAkBC,UAAU,GAAK,EACrC,OAAO,EAEX,GAAIjB,EAAI,EACJ,OAAO,EAEX,GAAIA,EAAIgB,EAAkBC,UAAU,GAAK,EACrC,OAAO,EAGX,OAAO,GA3DHsC,CAAOJ,IACPK,EAAiB/B,GAIrBA,EAAS,CAAEK,KAAM,aAAcqB,gBAE3BM,EAAc3D,EAAYqD,KAC1B1B,EAAS,CAAEK,KAAM,aAAcqB,gBAC/B1B,EAAS,CAAEK,KAAM,oBAAqBqB,YAAaO,EAAoB,aAVA,IAa/DX,EAb+D,YAavDjD,EAAWI,OAb4C,SAcvE6C,EAAKC,OAAS,GACVW,EAAcZ,EAAMI,KACpB1B,EAAS,CAAEK,KAAM,yBACjB0B,EAAiB/B,IAK7B,SAAS+B,EAAiB/B,GACtBI,cAAcf,GACdW,EAAS,CAAEK,KAAM,WACjB8B,YAAW,WACPnC,EAAS,CAAEK,KAAM,oBAAqBqB,YAAaO,EAAoB,YACvEjC,EAAS,CAAEK,KAAM,mBAAoBqB,YAAaO,EAAoB,iBACvE,KAGP,SAASA,EAAoB5B,GACzB,IAAM+B,EAAOC,KAAKC,MAAMD,KAAKE,SAAWhD,EAAkBC,UAAU,IAC9DgD,EAAOH,KAAKC,MAAMD,KAAKE,SAAWhD,EAAkBC,UAAU,IAQpE,OAFA2B,QAAQC,IAAIf,EAAO,oBAAqB,CAAC+B,EAAMI,IAExC,CAACJ,EAAMI,GAsBlB,IAAMR,EAAgB,SAAC3D,EAAiBqD,GACpC,OAAOA,EAAY,KAAOrD,EAAWY,YAAY,IAAMyC,EAAY,KAAOrD,EAAWY,YAAY,IAG/FiD,EAAgB,SAACZ,EAAWI,GAAZ,OAAsCJ,EAAKxC,MAAK,SAACC,GACnE,OAAOA,EAAG,KAAO2C,EAAY,IAAM3C,EAAG,KAAO2C,EAAY,OCtUtD,SAASe,IAGd,OACE,cAAC7C,EAAD,I,MCIW8C,MAZf,WACE,OACE,sBAAKvE,UAAU,MAAf,UACE,wBAAQA,UAAU,KAElB,+BACE,cAACsE,EAAD,UCIOE,EAZS,SAACC,GACnBA,GAAeA,aAAuBC,UACxC,6BAAqBC,MAAK,YAAkD,IAA/CC,EAA8C,EAA9CA,OAAQC,EAAsC,EAAtCA,OAAQC,EAA8B,EAA9BA,OAAQC,EAAsB,EAAtBA,OAAQC,EAAc,EAAdA,QAC3DJ,EAAOH,GACPI,EAAOJ,GACPK,EAAOL,GACPM,EAAON,GACPO,EAAQP,OCHdQ,IAASC,OAGP,cAAC,IAAMC,WAAP,UACE,cAAC,EAAD,MAEFC,SAASC,eAAe,SAM1Bb,M","file":"static/js/main.3723d0fd.chunk.js","sourcesContent":["import React from 'react';\nimport './point.css';\n\nexport function Point({ className = '', gameTrigger, boardState, x, y }: any) {\n\n\tconst isTarget = () => {\n\t\tif (x === boardState.targetPoint[0] && y === boardState.targetPoint[1]) {\n\t\t\treturn 'target';\n\t\t} else {\n\t\t\treturn '';\n\t\t}\n\t}\n\n\tconst isSnake = () => {\n\t\tconst [snakeBegin, ...restOfSnake] = boardState.snake;\n\n\t\tconst isHead = x === snakeBegin[0] && y === snakeBegin[1];\n\t\tconst isTail = restOfSnake.some((el: any) => {\n\t\t\treturn x === el[0] && y === el[1];\n\t\t});\n\n\t\tif (isHead) {\n\t\t\treturn 'snake head';\n\t\t} else if (isTail) {\n\t\t\treturn 'snake tail';\n\t\t} else {\n\t\t\treturn '';\n\t\t}\n\t}\n\n\tconst composedClassName = `${isTarget()} ${isSnake()} ${className}`;\n\n\tconst onPointClickHandler = (/* e: any */) => {\n\t\treturn !isSnake() ? gameTrigger([x, y]) : null;\n\t};\n\n\treturn <div className={`point ${composedClassName}`} onClick={onPointClickHandler}>{applyAxis(x, y)}</div>\n}\n\nfunction applyAxis(x: number, y: number) {\n\tlet index: any = '';\n\n\tif (x === 0 && y === 0) {\n\t\tindex = 0;\n\t} else if (x === 0 && y > 0) {\n\t\tindex = 'y' + y;\n\t} else if (y === 0 && x > 0) {\n\t\tindex = 'x' + x;\n\t}\n\n\treturn index;\n}\n","import React, { useReducer, PropsWithChildren } from 'react';\nimport { Point } from './Point';\nimport './board.css';\n\nconst FREQUENCY = 1000;\n\n// Array for axis used in format [x y] of two positive numbers:\n// y top-to-bottom and\n// x left-to-right\nconst initialBoardState = {\n    boardSize: [8, 8],\n    targetPoint: [2, 5],\n    snake: [[4, 5]],\n    // snake: [[4, 5], [4, 6], [5, 6], [6, 6]],\n    // snake: { // alternative\n    //     head: [],\n    //     tail: []\n    // },\n    started: false,\n    interrupt: false,\n    conflict: false, // target | 'itself' | 'edge' aka 'wall'\n};\n\nlet movingInterval: any;\n\n// Approach using <div> and css-grid layout\nexport function Board({ children }: PropsWithChildren<any>) {\n    // console.log('Board re-render');\n\n    const [boardState, dispatch] = useReducer(\n        boardReducer,\n        initialBoardState\n    );\n\n    const width = boardState.boardSize[0];\n    const height = boardState.boardSize[1];\n    // const matrix = Array(width).fill(null).map(el => Array(height).fill(0));\n    // console.log(matrix);\n\n    // This must be created on demand, after click for every cell once. NOT MORE\n    const gameTrigger = (newDirection: number[/* x y */]) => {\n        if (!boardState.started) {\n            dispatch({ type: 'START' });\n        } else {\n            clearInterval(movingInterval);\n            dispatch({ type: 'INTERRUPT' });\n        }\n\n        snakeMove(boardState, newDirection, dispatch);\n    };\n\n    const boardCore = [];\n    for (let x = 0; x < width; x++) {\n        for (let y = 0; y < height; y++) {\n            // console.log('loop re-invoke');\n            // TODO improve performance\n            // Every cell on the board changed, every snake moved, this loop will be re-invoked.\n            boardCore.push(<Point gameTrigger={gameTrigger} boardState={boardState} x={x} y={y} key={`cell-x[${x}]-y[${y}]`} />);\n        }\n    }\n\n    return (\n        <>\n            <div className=\"wrapper\">\n                {boardCore}\n            </div>\n            {children}\n        </>\n    );\n}\n\nfunction boardReducer(state: any, action: any) {\n    // console.log('boardReducer'); // TODO\n    // Due to using <React.StrictMode> useReducer() -> reducer() function is double-invoking !!!\n    // https://reactjs.org/docs/strict-mode.html#detecting-unexpected-side-effects\n    // console.log() inside of switch case is once, but random array is regenerated twice\n    // SOLUTION: move ANY logic BEFORE dispatch() and pass any new changed data via dispatch() func.\n    // https://github.com/facebook/react/issues/16295\n    // https://stackoverflow.com/questions/54892403/usereducer-action-dispatched-twice\n\n    switch (action.type) {\n        case 'START':\n            console.log('Game STARTED');\n            return {\n                ...state,\n                started: true // and start while(1) loop OR setInterval()\n            }\n\n        case 'FINISH':\n            console.log('Game Over!');\n\n            return {\n                ...state,\n                started: false, // and stop while(1) loop OR setInterval()\n                // targetPoint: generateRandomPoint('target'), // BAD\n                // snake: [generateRandomPoint('snakeHead')] // BAD\n            }\n\n        case 'SNAKE_MOVE': {\n            console.log('Snake is MOVING');\n\n            const [previousHead, ...tail] = state.snake;\n            if (tail.length > 0) {\n                tail.pop(); // remove last element\n                tail.unshift(previousHead); // add previous head as first\n            }\n\n            return {\n                ...state,\n                snake: [action.newPosition, ...tail],\n                interrupt: false\n            }\n        }\n\n        case 'GROW_SNAKE': {\n            console.log('Snake is GROWING');\n\n            // state.snake.unshift(action.newDirection);\n            // state.snake.pop(); // add a keyframe animation for slow fade out of last point on tail\n\n            // state.snake[0] = action.newPosition; // MUTABLE !!!!\n\n            // TODO\n            // const [snakeHead, ...snakeTail] = state.snake; // snakeTail can be undefined or many arrays [].length == 2\n            // TODO\n\n            const [head, ...tail] = state.snake;\n            tail.unshift(action.newPosition);\n\n            return {\n                ...state,\n                snake: [head, ...tail],\n                interrupt: false\n            }\n        }\n\n        case 'CONFLICT_WITH_TARGET': // MAYBE remove\n            console.log('Target point reached. Generating new one.');\n            // when snake eats target [xT, yT], size should be increased - new sub-array will be pushed to boardState.snake\n\n            return {\n                ...state,\n                // targetPoint: generateRandomPoint('target'), // BAD\n                // snake: [generateRandomPoint('snakeHead')] // BAD\n            }\n\n        case 'CONFLICT_WITH_ITSELF':\n            console.log('Don\\'t eat yourself');\n\n            return {\n                ...state,\n                conflict: 'itself',\n                // targetPoint: generateRandomPoint('target'), // BAD\n                // snake: [generateRandomPoint('snakeHead')] // BAD\n            }\n\n        case 'CONFLICT_WITH_EDGES':\n            console.log('Bang...');\n\n            return {\n                ...state,\n                started: false,\n                targetPoint: action.newPosition, // SHOULD BE OK\n                snake: [action.newSnakeHead] // SHOULD BE OK\n            }\n\n        case 'REGENERATE_TARGET':\n            console.log('Target point regeneration.');\n\n            return {\n                ...state,\n                targetPoint: action.newPosition, // IS OK\n            }\n\n        case 'REGENERATE_SNAKE':\n            console.log('Snake head point regeneration.');\n\n            return {\n                ...state,\n                snake: [action.newPosition], // IS OK. Will cause disappearing snake's tail, and head will be new point.\n            }\n        case 'INTERRUPT':\n            console.log('INTERRUPT');\n\n            return {\n                ...state,\n                interrupt: true\n            }\n\n        default:\n            return state;\n    }\n}\n\n/**\n * top: x = const, y--\n * bottom: x = const, y++\n * left: x--, y = const\n * right: x++, y = const\n *\n * @param boardState\n * @param newDirection\n * @param dispatch\n */\nfunction snakeMove(boardState: any, newDirection: any, dispatch: any) {\n    const snakeHead = boardState.snake[0];\n    const [snakeHeadX, snakeHeadY] = snakeHead;\n    const [xDirection, yDirection] = newDirection;\n\n    // it is LEFT or RIGHT move of snake head\n    if (yDirection === snakeHeadY) {\n\n        if (xDirection < snakeHeadX) { // -- loop = LEFT MOVE\n            let i = snakeHeadX - 1; // next left point\n            const callback = () => {\n                reDispatchMove(dispatch, boardState, [i, yDirection]);\n                --i; // maybe i--\n            };\n            movingInterval = setInterval(callback, FREQUENCY);\n        } else { // ++ loop = RIGHT MOVE\n\n            if (movingInterval) {\n                clearInterval(movingInterval);\n            }\n\n            let i = snakeHeadX + 1; // next right point\n            const callback = () => {\n                reDispatchMove(dispatch, boardState, [i, yDirection]);\n                ++i; // maybe i++\n            };\n            movingInterval = setInterval(callback, FREQUENCY);\n        }\n    } else {\n        // use case when clicked point NOT on the same Y axis\n    }\n\n    // it is TOP or BOTTOM move\n    if (xDirection === snakeHeadX) {\n        if (yDirection < snakeHeadY) { // -- for loop = TOP MOVE\n\n            let i = snakeHeadY - 1; // next top point\n            const callback = () => {\n                reDispatchMove(dispatch, boardState, [xDirection, i]);\n                --i;\n            };\n            movingInterval = setInterval(callback, FREQUENCY);\n\n        } else { // ++ for loop = BOTTOM MOVE\n\n            if (movingInterval) {\n                clearInterval(movingInterval);\n            }\n\n            let i = snakeHeadY + 1; // next bottom point\n            const callback = () => {\n                reDispatchMove(dispatch, boardState, [xDirection, i]);\n                ++i;\n            };\n            movingInterval = setInterval(callback, FREQUENCY);\n\n        }\n    } else {\n        // use case when clicked point NOT on the same X axis\n    }\n}\n\nfunction reDispatchMove(dispatch: any, boardState: any, newPosition: number[]) {\n    if (isWall(newPosition)) {\n        regeneratePoints(dispatch);\n        // return; // maybe ???\n    }\n\n    dispatch({ type: 'SNAKE_MOVE', newPosition });\n\n    if (isTargetEaten(boardState, newPosition)) {\n        dispatch({ type: 'GROW_SNAKE', newPosition });\n        dispatch({ type: 'REGENERATE_TARGET', newPosition: generateRandomPoint('target') });\n    }\n\n    const [, ...tail] = boardState.snake;\n    if (tail.length > 0) {\n        if (isItselfEaten(tail, newPosition)) {\n            dispatch({ type: 'CONFLICT_WITH_ITSELF' });\n            regeneratePoints(dispatch);\n        }\n    };\n}\n\nfunction regeneratePoints(dispatch: any) {\n    clearInterval(movingInterval);\n    dispatch({ type: 'FINISH' });\n    setTimeout(() => {\n        dispatch({ type: 'REGENERATE_TARGET', newPosition: generateRandomPoint('target') });\n        dispatch({ type: 'REGENERATE_SNAKE', newPosition: generateRandomPoint('snakeHead') });\n    }, 3000);\n}\n\nfunction generateRandomPoint(type: string) {\n    const newX = Math.floor(Math.random() * initialBoardState.boardSize[0]);\n    const newY = Math.floor(Math.random() * initialBoardState.boardSize[1]);\n\n    // Extend logic to avoid:\n    // same point as target, which was before\n    // same point of snake head or tail\n    // etc.\n    console.log(type + ' new random point', [newX, newY]);\n\n    return [newX, newY];\n}\n\nfunction isWall(point: number[]) {\n    const [x, y] = point;\n\n    if (x < 0) {\n        return true; // left edge, x has been decreasing towards 0\n    }\n    if (x > initialBoardState.boardSize[0] - 1) {\n        return true; // right edge, x has been increasing from positive number towards board width edge\n    }\n    if (y < 0) {\n        return true; // top edge, y has been decreasing towards 0\n    }\n    if (y > initialBoardState.boardSize[1] - 1) {\n        return true; // right edge, x has been increasing from positive number towards board height edge\n    }\n\n    return false;\n}\n\nconst isTargetEaten = (boardState: any, newPosition: number[]) => {\n    return newPosition[0] === boardState.targetPoint[0] && newPosition[1] === boardState.targetPoint[1];\n}\n\nconst isItselfEaten = (tail: any, newPosition: number[]) => tail.some((el: number[]) => {\n    return el[0] === newPosition[0] && el[1] === newPosition[1];\n});\n\n","import React from 'react';\nimport { Board } from './Board';\n// import { Point } from './Point';\n// import { Snake } from './Snake';\n\n// import './snake-game.css';\n\n// OR random   Math.random(10, 0);\nexport function SnakeGame() {\n  // dynamics, re-renders, etc\n\n  return (\n    <Board>\n    </Board>\n  );\n}\n","import React from 'react';\nimport { SnakeGame } from './components/SnakeGame';\nimport './App.css';\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <header className=\"\">\n      </header>\n      <main>\n        <SnakeGame />\n      </main>\n    </div>\n  );\n}\n\nexport default App;\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  // https://stackoverflow.com/questions/54892403/usereducer-action-dispatched-twice\n  // in strict mode, dispatch() from useReducer() was/is executed twice\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}